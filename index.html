<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Candy Crush Automated Simulation</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      #board {
        display: grid;
        grid-template-columns: repeat(11, 30px);
        gap: 2px;
        margin: 20px 0;
      }
      .cell {
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        color: white;
        border-radius: 4px;
      }
      .color-0 {
        background-color: #ddd;
      } /* Empty */
      .color-1 {
        background-color: red;
      } /* Red */
      .color-2 {
        background-color: yellow;
        color: #333;
      } /* Yellow */
      .color-3 {
        background-color: green;
      } /* Green */
      .color-4 {
        background-color: blue;
      } /* Blue */
      #startButton {
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <h1>Candy Crush Simulation</h1>
    <button id="startButton">Run Simulation</button>
    <div id="results"></div>
    <div id="board"></div>

    <script>
      const ROWS = 11;
      const COLS = 11;
      const EMPTY = 0;
      const RED = 1;
      const YELLOW = 2;
      const GREEN = 3;
      const BLUE = 4;
      const TARGET_SCORE = 10000;
      const TOTAL_GAMES = 100;

      let board;
      let isProcessing = false;
      let currentGame = 0;
      let totalScore = 0;
      let totalSwaps = 0;
      let gameScores = [];
      let gameSwaps = [];
      let score = 0;
      let swapCount = 0;

      function initializeBoard() {
        let board = [];
        for (let i = 0; i < ROWS; i++) {
          let row = [];
          for (let j = 0; j < COLS; j++) {
            row.push(Math.floor(Math.random() * 4) + 1);
          }
          board.push(row);
        }
        return board;
      }

      function displayBoard(board) {
        const boardElement = document.getElementById("board");
        boardElement.innerHTML = "";

        for (let row = 0; row < board.length; row++) {
          for (let col = 0; col < board[row].length; col++) {
            const cell = document.createElement("div");
            cell.classList.add("cell", `color-${board[row][col]}`);
            cell.textContent = board[row][col] === 0 ? "" : board[row][col];
            boardElement.appendChild(cell);
          }
        }
      }

      function displayResults(score, swapCount) {
        const resultsElement = document.getElementById("results");
        resultsElement.innerHTML = `
                <p><strong>Current Score:</strong> ${score}</p>
                <p><strong>Swaps so far:</strong> ${swapCount}</p>
                <p><strong>Games Played:</strong> ${currentGame}</p>
                <p><strong>Total Score So Far:</strong> ${totalScore}</p>
                <p><strong>Total Swaps So Far:</strong> ${totalSwaps}</p>
                <p><strong>Average Swaps So Far:</strong> ${
                  totalSwaps / currentGame
                }</p>
                
            `;
      }

      function checkAndClearFormations() {
        let points = 0;
        let markedForClear = Array.from({ length: ROWS }, () =>
          Array(COLS).fill(false)
        );

        // Check horizontal and vertical lines, and mark them
        for (let row = 0; row < ROWS; row++) {
          for (let col = 0; col < COLS; col++) {
            let candy = board[row][col];
            if (candy === EMPTY) continue;

            // Horizontal lines
            if (
              col <= COLS - 3 &&
              board[row][col + 1] === candy &&
              board[row][col + 2] === candy
            ) {
              let length = 3;
              while (col + length < COLS && board[row][col + length] === candy)
                length++;
              points += length === 3 ? 5 : length === 4 ? 10 : 50;
              for (let k = 0; k < length; k++)
                markedForClear[row][col + k] = true;
            }

            // Vertical lines
            if (
              row <= ROWS - 3 &&
              board[row + 1][col] === candy &&
              board[row + 2][col] === candy
            ) {
              let length = 3;
              while (row + length < ROWS && board[row + length][col] === candy)
                length++;
              points += length === 3 ? 5 : length === 4 ? 10 : 50;
              for (let k = 0; k < length; k++)
                markedForClear[row + k][col] = true;
            }
          }
        }

        // Clear marked candies
        for (let row = 0; row < ROWS; row++) {
          for (let col = 0; col < COLS; col++) {
            if (markedForClear[row][col]) board[row][col] = EMPTY;
          }
        }

        score += points;
        return points > 0;
      }

      function applyGravityAndGenerateNewCandies() {
        for (let col = 0; col < COLS; col++) {
          let emptyRow = ROWS - 1;
          for (let row = ROWS - 1; row >= 0; row--) {
            if (board[row][col] !== EMPTY) {
              board[emptyRow][col] = board[row][col];
              if (emptyRow !== row) board[row][col] = EMPTY;
              emptyRow--;
            }
          }
          for (let row = emptyRow; row >= 0; row--) {
            board[row][col] = Math.floor(Math.random() * 4) + 1;
          }
        }
      }

      function attemptToCreateFormation() {
        for (let row = 0; row < ROWS; row++) {
          for (let col = 0; col < COLS - 1; col++) {
            swap(board, row, col, row, col + 1);
            if (checkAndClearFormations()) {
              swapCount++;
              return true;
            }
            swap(board, row, col, row, col + 1);
            if (row < ROWS - 1) {
              swap(board, row, col, row + 1, col);
              if (checkAndClearFormations()) {
                swapCount++;
                return true;
              }
              swap(board, row, col, row + 1, col);
            }
          }
        }
        return false;
      }

      function swap(board, row1, col1, row2, col2) {
        [board[row1][col1], board[row2][col2]] = [
          board[row2][col2],
          board[row1][col1],
        ];
      }

      function runStep() {
        if (isProcessing) return; // Prevent multiple operations at once
        isProcessing = true;

        if (score >= TARGET_SCORE) {
          endGame();
          return;
        }

        if (attemptToCreateFormation()) {
          displayBoard(board);
          displayResults(score, swapCount);
          setTimeout(() => {
            do {
              checkAndClearFormations();
              applyGravityAndGenerateNewCandies();
              displayBoard(board);
            } while (checkAndClearFormations());

            isProcessing = false;
            setTimeout(runStep, 1); // Reduced delay to 1 ms
          }, 1); // Reduced delay to 1 ms
        } else {
          endGame();
        }
      }

      function endGame() {
        gameScores.push(score);
        gameSwaps.push(swapCount);
        totalScore += score;
        totalSwaps += swapCount;
        currentGame++;
        if (currentGame < TOTAL_GAMES) {
          setTimeout(startNewGame, 500); // Start new game after 0.5 seconds
        } else {
          displayResults(score, swapCount); // Final results
          isProcessing = false;
        }
      }

      function startNewGame() {
        // Reset game state
        board = initializeBoard();
        score = 0;
        swapCount = 0;
        displayBoard(board);
        displayResults(score, swapCount);
        isProcessing = false; // Allow new game processing to begin
        runStep();
      }

      document
        .getElementById("startButton")
        .addEventListener("click", function () {
          currentGame = 0;
          totalScore = 0;
          totalSwaps = 0;
          gameScores = [];
          gameSwaps = [];
          startNewGame();
        });
    </script>
  </body>
</html>
